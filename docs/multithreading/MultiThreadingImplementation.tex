\documentclass[]{article}

%opening
\title{Multithreading in \emph{stratisd}}
\author{mulhern}

\begin{document}

\maketitle

\begin{abstract}
TODO
\end{abstract}

\section{Introduction}
stratisd is an entirely single-threaded application; it is a daemon with a single event loop that consults a list of possible event sources in a prescribed order, handling the events on each event source before proceeding to the next. The event sources are udev, device-mapper, and D-Bus and events are handled in order of their source. stratisd can also be terminated cleanly by an interrupt signal, which it checks for on every loop iteration.

Consequently, every action taken by stratisd must be completed before another action is performed. For example, if a client issues a D-Bus message to create a filesystem, that command will be processed, the engine will create a filesystem, and a response will be transmitted on the D-Bus before any other action can be taken. If another D-Bus message is issued before the first is completed, the engine will continue to process D-Bus messages until none are left.

For this reason, stratisd itself can not parallelize long-running operations. It is well known that, for example, filesystem creation can be time consuming, as it is necessary to write the filesystem metadata when creating the filesystem. Ideally, stratisd would be able to run such time consuming operations in parallel, initiating one operation and then proceeding to initiate another before the first operation completes.

Additionally, as in the example above, if stratisd is continually receiving D-Bus messages, it will not proceed to deal with a device-mapper event, even if the device-mapper event is urgent and not in any conflict with the D-Bus messages, for example, if it is associated with a different pool than any D-Bus messages.

For these reasons, the next release introduces multi-threading capabilities into stratisd. These capabilities do not solve all the problems that multi-threading is intended to solve, but lay the essential foundation for multi-threaded event handling.

\section{Challenges}
\subsection{cryptsetup}
\texttt{libcryptsetup}\footnote{\texttt{https://mbroz.fedorapeople.org/libcryptsetup\_API/}}, which is the library that stratisd depends on for encryption operations, either through the libcryptsetup-rs Rust bindings\footnote{\texttt{https://crates.io/crates/libcryptsetup-rs}} or via invocations of Clevis command line utilities\footnote{\texttt{https://github.com/latchset/clevis}} does not itself support multi-threading. If stratisd were to use it in a multi-threaded manner, undefined behavior would undoubtedly result.

For cryptsetup operations that are initiated by Clevis, multi-threading is not possible, since at this time stratisd must invoke Clevis command-line utilites. However, for the operations that stratisd does directly via its Rust bindings, stratisd must enforce single-threading, and does so.

stratisd achieves this single-threaded operation by defining a single mutex within the stratisd crypt module, which manages all interaction between stratisd and the libcryptsetup library. Every publicly available method must enter the mutex before an operation can be performed.

\section{Multi-threading Choices}
We have chosen to implement multi-threading using the Rust tokio\footnote{\texttt{https://tokio.rs/}} and async-std\footnote{\texttt{https://async.rs/}} crates. The alternative is to use operating system threads explicitly via the Rust standard library thread\footnote{\texttt{https://doc.rust-lang.org/std/thread/}} module. We have chosen `tokio` in order to get the benefits of code reuse from the `tokio` runtime, and because we expect that this choice will allow stratisd to operate efficiently while consuming fewer operating system resources.

\section{Introduction to Multithreading}
\subsection{async, await, and Future}

The async keyword was introduced in Rust 1.39\footnote{\texttt{https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html}}. Much information is available via the blog post. However, the key things to understand are the following:

\begin{itemize}
\item Adding the \texttt{async} keyword to a code block or function causes the block or function to be transformed to a block or function implementing the \texttt{Future}\footnote{\texttt{https://doc.rust-lang.org/std/future/trait.Future.html}} trait.

\item Invoking a function or executing a block that implements the \texttt{Future} trait has no effect.

\item Applying the \texttt{await} operator to the result of such an invocation forces the computation to begin to be executed.

\item It is forbidden to apply the \texttt{await} operator outside an \texttt{async} block or function.
\end{itemize}

The alert reader will notice that these rules appear to prohibit all execution of any \texttt{async} code , since the \texttt{async} keyword defers all computation, but the \texttt{await}` operator, which forces the computation, can only be used within a block or function with the \texttt{async} keyword.

To have any of this \texttt{async} code executed requires an \emph{executor} about which more later.

\section{Making the Engine \texttt{Send}}
Another essential component of the transformation from single-threaded to multi-threaded operation is transforming the stratisd `Engine` trait and the sim and real engine that implement the trait so that they are \texttt{Send}. That is
ownership of the engine can be transferred between threads without any possibility that there will be a race condition on the engine between the threads.

Of course, core Rust has an ownership model that makes any sharing between threads impossible. However, there are many cases where it is necessary to have two pointers to the same object. Rust supports this via the reference-counted pointer implementations in the standard library, \texttt{Rc} and \texttt{Arc}. The pointers share the common property that any pointer can be cloned to make another copy of itself. When all pointers to an object are collected, so is the object itself. When there are two pointers to an object, it is indeed possible for the object to become shared between threads, as ownership of one pointer is transferred but the other is left behind.

Rust must guarantee that the reference counts are always correct, otherwise the object pointed may be reclaimed early or leak permanently. What distinguishes \texttt{Arc} from \texttt{Rc} pointers is that the \texttt{Arc} pointers implement atomic updates on their reference counters. Atomic updates
guarantee that there will never be a race condition on the reference counters. Consequently, \texttt{Arc} pointers are always \texttt{Send}, but \texttt{Rc} pointers never are.

Our chief concern in the single-threaded stratisd implementation is that the engine itself must be shared. stratisd implements an optional, but vital, D-Bus layer, and it is necessary that the D-Bus connection have a reference to the engine so that when D-Bus method calls are received the D-Bus layer can invoke engine methods.

\section{async-std implementations for the Rust standard libary}
async-std is a crate that supplies async reimplementations of some Rust standard library modules: fs, io, net, path, and
sync. Generally, these implementations wrap the Rust standard library implementations to allow asynchronous computations.

`stream` is a module for asynchronous iterators. Each element of a `Stream` can be accessed asynchronously. `Stream`s can be composed in the same ways that iterators can be composed, typically by using the standard methods, such as `filter`.

\section{Example: Implementation of Stream for DmFd}
The struct DmFd and its implementation comprise the basic mechanism by which stratisd handles device mapper events. In particular, DmFd implements the `Stream` trait, and a higher level stratisd function includes a loop which repeatedly invokes `next()` on the DmFd object. `next()` is an asynchronous function, so at every iteration of the loop the computation must be forced with the `await` keyword.

\section{The `unsafe` boundary in `stratisd`}
TODO: Discussion of our wrapper libraries. Implementing Send and Sync.
TODO: Requirements of unsafe code.

\section{Statistics}
Using `tokio` increases the size of the `stratisd` executable by about 1 MiB, which at `stratisd`'s current size is an increase of approximately 20%.	

\end{document}
